"""Fill Bin.

Fills the waste bin with trash. This script takes the bin generated by
bin_generator.py and adds blobs from shape_generator.py sequentially into the
bin, creating image sequences along with their annotations.

Author:
    Yvan Satyawan <y_satyawan@hotmail.com>

Created on:
    March 30, 2020
"""
from PIL import Image, ImageDraw
from os.path import join, abspath, split
import numpy as np
from math import ceil
from random import randint, choice

from trash_generator.bin_generator import generate_bin
from trash_generator.shape_generator import Shapes


class BinSequence:
    def __init__(self, h=800, w=1024):
        """Class that can generate sequences of h, w bin images.

        Generates an image with 40 classes, of which only the first 20 classes
        should be classified.

        :param int h: Height of image.
        :param int w: Width of image

        :Example:
        >>> b = BinSequence()
        >>> img_sequence = b.generate_sequence()
        >>> for img, seg_gt in img_sequence:
        >>>     img.show()
        """
        self.h = h
        self.w = w
        self.class_colors = ['#d60000', '#8c3bff', '#018700', '#00acc6',
                             '#97ff00', '#ff7ed1', '#6b004f', '#ffa52f',
                             '#573b00', '#005659', '#0000dd', '#00fdcf',
                             '#a17569', '#bcb6ff', '#95b577', '#bf03b8',
                             '#645474', '#790000', '#0774d8', '#fdf490',
                             '#004b00', '#8e7900', '#ff7266', '#edb8b8',
                             '#5d7e66', '#9ae4ff', '#eb0077', '#a57bb8',
                             '#5900a3', '#03c600', '#9e4b00', '#9c3b4f',
                             '#cac300', '#708297', '#00af89', '#8287ff',
                             '#5d363b', '#380000', '#fdbfff', '#bde6bf']

        self.patterns = self._generate_patterns()
        self.bin_bg = None
        self.bin_mask = None
        self.inside_pos = None
        self.inside_dim = None
        self.color_bg, self.color_out, self.color_in = None, None, None
        self._randomize_bin()
        self.shapes = Shapes()

    def _generate_patterns(self):
        """Generates patterns blended with the colors representing each class.

        :returns: A list of tiled versions of each pattern as large as the
            main image size.
        :rtype: list
        """
        patterns = []
        reps = [ceil(self.h / 200), ceil(self.w / 200)]
        pattern_dir = join(split(split(abspath(__file__))[0])[0], 'patterns')
        for i, color in enumerate(self.class_colors):
            img = Image.open(join(pattern_dir, f'pattern__{i:04}.png'))

            # Tile the image and crop it to the main size
            img_array = np.array(img)
            tiled = np.tile(img_array, reps)
            img_tiled = Image.fromarray(tiled).crop((0, 0, self.w, self.h))
            img_tiled = img_tiled.convert('RGB')

            color_layer = Image.new('RGB', (self.w, self.h), color=color)
            pattern = Image.blend(img_tiled, color_layer, .5)
            patterns.append(pattern.convert('RGB'))
        return patterns

    @staticmethod
    def _choose_colors():
        """Chooses a random selection of colors from the color lists above.

        :returns A tuple with colors for background, bin exterior, and bin
            interior.
        :rtype: tuple
        """
        bg_colors = ['#D9D9D9', '#CBD8CD', '#B6B4D4', '#FFFFFF', '#90A2C3',
                     '#848588', '#FFF7BC']
        outside_colors = ['#ED1C24', '#F68E56', '#363636', '#00A651', '#0054A6']
        inside_colors = ['#111111', '#F4F4F4']

        return choice(bg_colors), choice(outside_colors), choice(inside_colors)

    def _randomize_bin(self):
        self.color_bg, self.color_out, self.color_in = self._choose_colors()

        self.bin_bg, self.bin_mask, self.inside_pos = generate_bin(
            self.color_bg, self.color_out, self.color_in, self.h, self.w
        )

        self.inside_dim = (self.inside_pos[2] - self.inside_pos[0],
                           self.inside_pos[3] - self.inside_pos[1])

    def generate_sequence(self, n, randomize_bin=False, top_20_white=False):
        """Generates the image sequence.

        The top 20 classes are classes [0, 19]

        :param int n: Length of the image sequence to generate.
        :param bool randomize_bin: Whether or not to generate a new bin.
        :param bool top_20_white: Whether or not to use a white background
            (int value 255) for the top_20_masks. Used for visibility purposes.
        :returns: The generated image sequence as a list of PIL Image files and
            their corresponding ground truth masks. The first GT mask is the
            binary new object mask and the second is the segmentation of the
            top 20 classes. The final dictionary is a mapping where the keys are
            the colors used in the top_20_gt image and the values are their
            actual labels.
        :rtype: list[PIL.Image, PIL.Image, PIL.Image, dict]
        """
        if randomize_bin:
            self._randomize_bin()

        t20_color = 255 if top_20_white else 0

        img_sequence = []
        seq_bin = self.bin_bg.copy()
        trash = Image.new('RGB', (self.w, self.h), color=self.color_in)
        for _ in range(n):
            # Ground truth images
            new_object_gt = Image.new('L', (self.w, self.h), color=0)
            top_20_gt = Image.new('L', (self.w, self.h), color=t20_color)

            # Randomly choose how many instances and their classes will appear
            # in the image
            instances = [randint(0, 39) for _ in range(randint(1, 5))]
            label_mapping = dict()
            for i, label in enumerate(instances):
                # For each object instance, generate a blob and translate and
                # scale it to somewhere inside the bin
                blob = self.shapes.get_blob(10, 25).T
                factor = np.random.uniform(0.1, 0.8, [2])
                scale = self.inside_dim * factor
                blob *= scale
                translate = [randint(0, self.inside_dim[0]),
                             randint(0, self.inside_dim[1])]
                blob += np.array(translate)

                # Now turn it into a mask using polygon from PIL
                blob = blob.flatten().tolist()
                instance_mask = Image.new('1', (self.w, self.h), 1)
                instance_draw = ImageDraw.Draw(instance_mask)
                instance_draw.polygon(blob, fill=0)

                bitmap_mask = Image.new('1', (self.w, self.h), 0)
                bitmap_draw = ImageDraw.Draw(bitmap_mask)
                bitmap_draw.polygon(blob, fill=1)

                # Add the mask to the new_object ground truth
                new_object_gt.paste(255, mask=bitmap_mask)

                # Add the mask to the top_20 ground truth if it's in the top 20
                if label < 20:
                    top_20_gt.paste(i + 1, mask=bitmap_mask)
                    label_mapping[i + 1] = label
                # Use the mask to add trash
                trash = Image.composite(trash, self.patterns[label],
                                        instance_mask)

            # Use the inside mask to add trash to the bin
            composed_img = Image.composite(seq_bin, trash, self.bin_mask)
            new_object_gt.paste(0, self.bin_mask)
            top_20_gt.paste(t20_color, self.bin_mask)
            img_sequence.append((composed_img, new_object_gt, top_20_gt,
                                 label_mapping))

        return img_sequence


if __name__ == '__main__':
    b = BinSequence(300, 400)
    for i, img in enumerate(b.generate_sequence(10)):
        img[0].save(f'img_{i}.png')