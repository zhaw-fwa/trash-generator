"""Fill Bin.

Fills the waste bin with trash. This script takes the bin generated by
bin_generator.py and adds blobs from shape_generator.py sequentially into the
bin, creating image sequences along with their annotations.

Author:
    Yvan Satyawan <y_satyawan@hotmail.com>

Created on:
    March 30, 2020
"""
from PIL import Image, ImageDraw
from os.path import join
import numpy as np
from math import ceil, floor
from random import randint, uniform, choice

from .shape_generator import generate_random_shape


class BinSequence:
    def __init__(self, h=800, w=1024):
        """Class that can generate sequences of h, w bin images.

        :param h: Height of image.
        :param w: Width of image
        :type h: int
        :type w: int

        :Example:
        >>> b = BinSequence()
        >>> b.generate_sequence(20)
        """
        self.h = h
        self.w = w
        self.class_colors = ['#d60000', '#8c3bff', '#018700', '#00acc6',
                             '#97ff00', '#ff7ed1', '#6b004f', '#ffa52f',
                             '#573b00', '#005659', '#0000dd', '#00fdcf',
                             '#a17569', '#bcb6ff', '#95b577', '#bf03b8',
                             '#645474', '#790000', '#0774d8', '#fdf490']

        self.patterns = self._generate_patterns()
        self.bin_bg = None
        self.bin_mask = None
        self.inside_pos = None
        self.inside_dim = None
        self._randomize_bin()

    def _generate_patterns(self):
        """Generates patterns blended with the colors representing each class.

        :returns: A list of tiled versions of each pattern as large as the
            main image size.
        :rtype: list
        """
        patterns = []
        reps = [ceil(self.h / 200), ceil(self.w / 200)]
        for i, color in enumerate(self.class_colors):
            img = Image.open(join('patterns', f'pattern_{i}.png'))

            # Tile the image and crop it to the main size
            img_array = np.array(img)
            tiled = np.tile(img_array, reps)
            img_tiled = Image.fromarray(tiled).crop((0, 0, self.w, self.h))
            img_tiled = img_tiled.convert('RGB')

            color_layer = Image.new('RGB', (self.w, self.h), color=color)
            pattern = Image.blend(img_tiled, color_layer, .5)
            patterns.append(pattern.convert('RGBA'))
        return patterns

    def _randomize_bin(self):
        self.bin_bg, self.bin_mask, self.inside_pos = generate_bin(self.h,
                                                                   self.w)
        self.inside_dim = (self.inside_pos[2] - self.inside_pos[0],
                           self.inside_pos[3] - self.inside_pos[1])

    @staticmethod
    def _choose_colors():
        """Chooses a random selection of colors from the color lists above.

        :returns A tuple with colors for background, bin exterior, and bin
            interior.
        :rtype: tuple
        """
        bg_colors = ['#D9D9D9', '#CBD8CD', '#B6B4D4', '#FFFFFF', '#90A2C3',
                     '#848588', '#FFF7BC']
        outside_colors = ['#ED1C24', '#F68E56', '#363636', '#00A651', '#0054A6']
        inside_colors = ['#111111', '#F4F4F4']

        return choice(bg_colors), choice(outside_colors), choice(inside_colors)

    def _generate_bin(self):
        """Generates a waste bin based on the given image dimensions.

        This function generates a waste bin somewhere in the middle of an
        image with
        the given dimensions. The waste bin makes up most of the center of
        the image
        but maybe offset randomly.

        :returns: A waste bin image with mode 'RGB', a binary mask with values
            True where the inside of the bin is as an np.ndarray with shape
            (h, w), and a list with the [x0, y0, x1, y1] coordinates of the
            inside of the bin.
        :rtype: tuple
        """
        # First pick the necessary colors
        bg, outside_color, inside_color = self._choose_colors()

        img = Image.new('RGB', (self.w, self.h), bg)
        draw = ImageDraw.Draw(img)

        # Figure out dimensions of waste bin. It is based on the minor axis of
        # the image and is always squared or circular.
        bin_radius = uniform(0.75, 1.0) * min(self.h, self.w) / 2
        bin_lip = min(self.h, self.w) / 20
        inside_width = bin_radius - bin_lip

        # Choose where to place the bin as an x, y translation from the image
        # center
        max_shift = min(self.h, self.w) / 20
        bin_center = (uniform(-max_shift, max_shift) + self.w / 2,
                      uniform(-max_shift, max_shift) + self.h / 2)

        # Calculate bin bounding box
        outside_dim = [bin_center[0] - bin_radius,
                       bin_center[1] - bin_radius,
                       bin_center[0] + bin_radius,
                       bin_center[1] + bin_radius]

        inside_dim = [bin_center[0] - inside_width,
                      bin_center[1] - inside_width,
                      bin_center[0] + inside_width,
                      bin_center[1] + inside_width]

        outside_dim = [int(i) for i in outside_dim]
        inside_dim = [int(i) for i in inside_dim]

        # Create mask
        mask = Image.new('1', (self.w, self.h), color=0)
        mask_draw = ImageDraw.Draw(mask)

        # Choose bin shape
        bin_shape = choice(['circular', 'square'])
        if bin_shape == 'circular':
            draw.ellipse(outside_dim, fill=outside_color)
            draw.ellipse(inside_dim, fill=inside_color)
            mask_draw.ellipse(inside_dim, fill=1)
        else:
            draw.rectangle(outside_dim, fill=outside_color)
            draw.rectangle(inside_dim, fill=inside_color)
            mask_draw.rectangle(inside_dim, fill=1)

        # Generate inside binary mask
        mask = np.array(mask)

        return img, mask, inside_dim

    def generate_sequence(self, n, randomize_bin=False):
        """Generates the image sequence.

        :param n: Length of the image sequence to generate.
        :param randomize_bin: Whether or not to generate a new bin.
        :type n: int
        :type randomize_bin: bool
        :returns: The generated image sequence as PIL Image files.
        :rtype: list
        """
        if randomize_bin:
            self._randomize_bin()

        img_sequence = []
        seq_bin = self.bin_bg.copy()
        for i in range(n):
            # Randomly choose how many instances and their classes will appear
            # in the image
            trash = Image.new('RGBA', (self.w, self.h), color=(0, 0, 0, 0))
            instances = [randint(0, 20) for _ in range(randint(5))]
            for label in instances:
                # For each object instance, generate a blob and translate and
                # scale it to somewhere inside the bin
                blob = generate_random_shape(10, 25)
                factor = np.random.uniform(0.3, 1.0, [2])
                scale = self.inside_dim * factor
                blob *= scale
                translate = [randint(0, self.inside_dim[0]
                                     - floor(scale[0] / 2)),
                             randint(0, self.inside_dim[1]
                                     - floor(scale[1] / 2))]
                blob += np.array(translate)

                # Now turn it into a mask using polygon from PIL
                blob = blob.T.tolist()
                instance_mask = Image.new('1', (self.w, self.h), 0)
                instance_draw = ImageDraw.Draw(instance_mask)
                instance_draw.polygon(blob, fill=1)

                # Use the mask to add trash
                trash = Image.composite(trash, self.patterns[label],
                                        instance_mask)

            # Use the inside mask to add trash to the bin
            img_sequence.append(Image.composite(seq_bin, trash, self.bin_mask))

        return img_sequence


if __name__ == '__main__':
    b = BinSequence()
    img_sequence = b.generate_sequence(20)
    for img in img_sequence:
        img.show()
        input('Continue?')
